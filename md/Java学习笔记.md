# java学习

## java基础

### java三大版本

> JavaSE	标准版(桌面程序,控制台开发)
>
> JavaME	嵌入式开发(了解一下就行)
>
> JavaEE	企业级开发(web端,服务器)

### JDK、JRE、JVM

JDK：Java Development Kit

JRE：Java Runtime Environment

JVM：Java Virtual Machine

### IDEA

Hello World

> 1.大小写敏感
>
> 2.文件名和类名必须一致,首字母大写

```java
public class Hello{
    public static void main{
        System.out.print("Hello World!");
    }
}
```

### 注释

单行、多行和文档注释

### 标识符

字母、下划线和$开头(大小写敏感)

**修饰符**不存在先后顺序

> final 
>
> 修饰类：这个类不能被继承。该类的所有成员方法隐性的被指定为final方法
>
> 修饰方法：只有在想明确禁止该方法在子类中被覆盖的情况下才将方法设置为final的。类的private方法会被隐性的指定为final方法。
>
> 修饰变量：如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。

> static
>
> 概述：方便在没有创建对象的情况下来进行调用（方法/变量）。所有的静态方法和静态变量都可以通过对象访问（只要访问权限足够）。static是不允许用来修饰局部变量。
>
> 修饰类：
>
> 修饰方法：称为静态方法。静态方法不依赖任何对象就可以进行访问，所以对于静态方法是没有this的。在静态方法中不能访问类的非静态成员变量和非静态成员方法，因为非静态成员方法/变量都是必须依赖具体的对象才能够被调用。反之则可以。
>
> 修饰变量：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。

> static代码块：static关键字还有一个比较关键的作用就是 用来形成静态代码块以优化程序性能。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。

访问权限修饰符

| 修饰符    | 当前类 | 同一包内 | 子孙类(同一包) | 子孙类(不同包) | 不同包 |
| --------- | ------ | -------- | -------------- | -------------- | ------ |
| public    | Y      | Y        | Y              | Y              | Y      |
| protected | Y      | Y        | Y              | Y/N            | N      |
| default   | Y      | Y        | Y              | N              | N      |
| rprivate  | Y      | N        | N              | N              | N      |

使用默认访问修饰符声明的变量和方法，对同一个包内的类是可见的。接口里的变量都隐式声明为 **public static final**,而接口里的方法默认情况下访问权限为 **public**。被声明为 **private** 的方法、变量和构造方法只能被所属类访问，并且类和接口不能声明为 **private**。

### 数据类型

基本类型

> byte、int、short
>
> long	要在数字最后加L
>
> float	要在数字最后加F
>
> double
>
> boolean	true or false
>
> char
>
> String	字符串（一个类）

整数扩展

> 0b	二进制
>
> 0	   八进制
>
> 0x	十六进制

浮点数拓展

> 最好完全**避免**使用浮点数进行比较

> rBigDecimal	数学工具类

字符拓展

> **所有的字符还是数字**

引用类型

### 类型转换

**运算中,转换为统一类型再进行运算**

强制转换	(类型)变量名	高->低

自动转换							低->高

> ***注意***
>
> **不能对boolean进行转换**
>
> 不能把对象类型转换为不相干的类型
>
> 在把高容量转换到低容量的时候,强制转换
>
> 可能出现内存溢出,或者精度问题

### 变量

#### 变量作用域

- 类变量	关键字static

```java
public class Hello{
    static int allClicks=0;		//类变量
    String str="Hello";			//实例变量。默认初始化为这个类型的默认值
    //main方法
    public static void main(String[] args){
        
    }
}
```



- 实例变量
- 局部变量

#### 

---

### final

final定义的常量运行过程中不允许被改变。一般用大写字符。

final定义的方法不允许被重写。效率高于非final方法.

final类, final类不能被继承

const	(java中没有const关键字)

---

### 常量

### 命名规范

- 见名知意
- 类成员变量：首字母小写和驼峰原则eg：nameSalary
- 局部变量：首字母小写和驼峰原则
- 常量：大写字母和下划线eg：MAX_VALUE
- 类名：首字母大写和驼峰原则
- 方法：首字母小写和驼峰原则

### 运算符

关系运算符：instanceof	>	<	>=	<=	==	!=

### 包机制

+ 包语法格式

> package	pkg1[.pkg2[.pkg3]];

- ***一般利用公司域名倒置作为包名***, 个人用户随意把

+ 导入包

> import	package	pkg1[.pkg2[.pkg3]];

### JavaDOC

## 流程控制

### Scanner对象输入

​	通过Scanner类来获取用户的输入

​	基本语法

> Scanner s = new Scanner(System.in);

> next()和nextLine()方法获取输入的字符串.
>
> 使用hasNext()和hasNextLine()判断是否有输入数据.

###  顺序结构

if

switch case

while	do...while	for

增强for循环

```java
for (声明语句 : 表达式){
    //代码
}
```

```java
int numbers[] = [1,2,3,4];
for(int i : numbers){
    System.out.print(i);
}
输出结果:
1234
    
//增强型for.遍历数组
```

### break 和 continue

break : 跳出当前循环

continue : 结束剩余循环,进入下一次的判断.

**跳转**

break/continue label;		跳到label标签处

## 方法

​	语句的集合,执行依一个功能.

​	设计方法的原则:一个方法只执行一个功能,便于后期拓展.

​	命名规则:驼峰

定义和调用

### 方法的重载

​	重载就是在一个类中,有相同函数名称,但形参不同的函数.

**重载规则**:

- 名称相同
- 参数列表不同(个数,类型或排列顺序不同)
- 仅返回类型不同不足以成为方法的重载

**实现理论**:

- 编译器会根据方法参数个数、类型或顺序逐个匹配，失败则报错。

### 可变参数

- 在方法声明中,在制定参数类型后加一个省略号(...)
- 一个方法中只能指定一个可变参数,它必须是方法的最后一个参数.任何普通参数在其之前声明.

```java
public class VariableParameter{
    public static void main(String[] args){
        //main code
    }
    //可传递不限个整数参数
    public void example(int... i){
        //example code
    }
}
```

### 递归

​	自己调用自己.

+ 递归头:什么时候不调用自身方法,若无递归头,将陷入死循环.
+ 递归体:什么时候调用自身方法.

## 数组

- 相同类型数据的有序结合.
- 按照一定的先后次序.
- 通过下标访问.

### 声明和创建

> 类型名[]	数组名;	//首选
>
> 类型名	数组名[];	//效果相同

- 数组变量属引用类型,数组也可以看成是对象,数组中的每个元素相当于该对象的成员变量.
- **数组对象本身是在堆中**

### 内存分析

Java内存:

> 堆	:存放new的对象和数组
>
> ​		:可以被所有的线程共享,不会存放别的对象引用

> 栈	:存放基本变量类型(会包含这个基本类型的具体数值)
>
> ​		:引用对象的变量(会存放这个引用在堆里面的具体地址)

> 方法区	:可以被所有的线程共享
>
> ​			  :包含所有的class和static

### 数组边界

> [0,length-1]

> ArrayIndexOutOfBoundsExcption	数组下标越界

数组名.length	数组长度

**多维数组**

**Arrays类**

### 稀疏数组

- 当一个数组中大部分元素为没有意义的数据(比如0或者为同一数值),可以使用稀疏数组来保存该数组.
- 处理方式
  - 记录数组共有几行几列,多少个不同数值.
  - 把据有不同值的元素和行列以及值记录在一个小规模的数组中,从而缩小程序规模.

## 面向对象

​	属性 + 方法 == 类

+ 分类的思维模式,解决问题需要哪些分类,然后对分类进行单独思考.
+ 面向对象适合处理复杂的、需要多人协作的问题.

> ***以类的方式组织代码,以对象的组织(封装)数据***

### 三大特性:

+ **封装**
+ **继承**
+ **多态**

### **方法**

- 一个点

```java
public class Demo{
    public static void main(String[] args){
        
    }
    //和类一起加载的.(静态方法)
    public static void test1(){
        
    }
    //类实例化后才存在(非静态方法)
    public void test2(){
        
    }
}
test1可以直接调用test2,反之不可以.
```

> 值传递和引用传递

### this 和 new

### 创建和初始化对象

+ **使用new关键字创建对象**
+ 使用new创建时,除了分配内存空间外,还会给对象进行默认初始化以及对类中构造器的调用
+ 类中的构造器也称为构造方法,是在进行创建对象的时候必须要调用的,并且构造器有俩特点:
  + 1,必须和类的名字相同
  + 2.必须没有返回类型,也不能写void
+ **构造器必须要掌握**

### 构造器

- 与类名相同
- 没有返回值
- 类默认有一个构造器
- new关键字本质是调用构造器
- 一旦定义了有参构造,必须显示(构造器)无参定义

new两个对象

![image-20210610193202416](/home/chyx/.config/Typora/typora-user-images/image-20210610193202416.png)

### 小结

1类与方法

​	类是模板,抽象概念.	对象是具体实例

2方法

​	方法的定义与调用

3对应的引用

​	引用类型	和	基本类型(8个)

4属性

​	属性初始化

> char	u0000
>
> 数字	0	0.0
>
> boolean	false
>
> 引用	null

​	修饰符	属性类型	属性名 = 属性值

5对象的创建和使用

​	new关键字,构造器	类名 对象名 = new 类名();

​	对象的属性	对象名.属性名

​	对象的方法	对象名.方法名()

6类

​	静态的属性	属性

​	动态的行为	方法

### 封装

​	对属性

​	程序设计要求:"高內聚,低耦合". 高內聚指类的内部数据操作细节自己完成,不允许外部干涉. 低耦合指仅有少许方法供外部使用

​	封装(数据的隐藏)

​			通常,应禁止直接访问一个对象中数据的实际表示.而应通过操作接口来访问.这称为信息隐藏.

​	**属性私有**,get/set

> 提高安全性
>
> 隐藏代码实现细节
>
> 统一接口
>
> 可维护性增加

### 继承

​	extendds关键字

Java中类只有单继承,没有多继承

默认继承object类

语法格式:public class test1 extends test2{}

**super**

- 调用父类的构造方法,必须在构造方法的第一个
- 只能出现在子类的方法好哦构造方法中
- 不能与this同时构造方法.
- super()调用父类的构造

**this**

- 本身调用者这个对象
- 没继承也可用
- this()调用本类的构造

**方法重写**

​	需要有继承关系. 子类继承父类的方法.重写与属性无关.

+ 方法名必须相同,方法体不同
+ 参数列表必须相同(否则就变重载了)
+ 修饰符范围可以扩大,但不能缩小.public->protected->default->private
+ 抛出的异常:范围可以缩小,但不能扩大.ClassNotFountExcption->Exception(大)

> 为什么要重写

父类的功能子类不一定需要,或者不满足

### **向上转型**



### 多态

instanceof :判断一个对象是什么类型

强制转换:减少重复代码的使用

### static详解

### 抽象类

​	只有名字,没有属性和方法.其方法得由子类完成.

​	abstract	定义抽象类(方法)关键字.

### 接口

接口里的变量都隐式声明为 **public static final**,而接口里的方法默认情况下访问权限为 **public**。

> interface定义

## 异常

+ Java把异常常当作对象来处理,并定义一个基类java.lang.Throwable作为所有异常的超类.
+ 两大类:错误Error和异常Exception

### 异常处理机制

抛出异常

捕获异常

异常处理关键字

- try	catch	finally	throw	throws

常用类

![image-20210610231209155](/home/chyx/.config/Typora/typora-user-images/image-20210610231209155.png)

## 注解(Annotation)

- 作用在代码的注解
  - @Override	检查该方法是否是重写方法,若父类或引用的接口i没有该方法则报错.
  - @Deprecated 标记过时方法,引用该方法则报错.
  - @SuppressWarnings 指示编译器去忽略注解中声明的警告.

- 作用在其他注解的注解(元注解)
  - @Retention 标识这个注解怎么保存,是在代码中,还是编入class文件,还是运行是可以通过反射访问.
  - @Documented 标记这些注解是否包含在用户文档中.
  - @Target 标记这个注解应该是哪种java成员.
  - @Inherited 标记这个注解是继承于哪个注解类

从Java7开始新增三个

- @SafeVarags 忽略任何使用参数为泛型变量的方法或构造方法调用产生的警告.
- @FunctionalInterface 标识一个匿名函数或函数式接口.
- @Repeatable 标识某注解可以在同一个声明上使用多次.

## 反射

反射是在运行状态中,对于任意一个类,都能知道这个类的所有属性和方法.对于任意一个对象,都能够调用他的任意一个方法和属性.这种动态获取信息以及动态调用对象的方法的共能成为反射.

反射调用:三种方式:new对象,类名,路径

> Foo foo = new Foo();
>
> 1. Class cla = foo.getClass();
> 2. Class cla = Foo.class;
> 3. Class cla = Class.forName("xx.xx.Foo");

## 多线程

多线程与多进程:包含关系.进程包含线程.一个进程可以包含多个线程.

多进程的缺点:

- 创建进程比创建线程开销大
- 进程间通信比线程间通信要慢,因为线程间通信就是读写同一个变量,速度很快.

优点:

- 稳定性比多线程高.一个进程崩溃不会影响其他进程,而在多线程下,任何一个线程崩溃都会直接导致整个进程崩溃.
